# **Multi-model Databases: A New Journey to Handle the Variety of Data**

# 多模型数据库-处理各种数据的新旅程

The variety of data is one of the most challenging issues for the research and practice in data management systems. The data are naturally organized in different formats and models, including structured data, semi structured data and unstructured data. In this survey, we introduce the area of multi-model DBMSs which build a single database platform to manage multi-model data. Even though multi-model databases are a newly emerging area, in recent years we have witnessed many database systems to embrace this category. We provide a general classifification and multi-dimensional comparisons for the most popular multi-model databases. This comprehensive introduction on existing approaches and open problems, from the technique and application perspective, make this survey useful for motivating new multi-model database approaches, as well as serving as a technical reference for developing multi-model database applications.

数据的多样性是数据管理研究和实践中最具挑战性的问题之一。系统。数据自然以不同的格式和模型组织起来，包括结构化数据、半结构化数据和非结构化数据。在本次调查中，我们介绍了多模型DBMS的领域，它的特点是 构建一个单一的数据库平台来管理多模型数据。尽管多模型数据库是一个很好的平台，但它是一个很好的平台。新兴的领域，近年来，我们见证了许多数据库系统来拥抱这个范畴。我们为最流行的多模型提供了一个通用的分类和多维度的比较。数据库。本次全面介绍了现有的方法和开放的问题，从技术上讲 和应用的角度，使得这项调查对激励新的多模型数据库方法很有帮助。以及作为开发多模型数据库应用的技术参考。

---

CCS Concepts: Information systems → Database design and models; Data model extensions; Semistructured data; Database query processing; Query languages for non-relational engines; Extraction, transformation and loading; Object-relational mapping facilities;
Additional Key Words and Phrases: Big Data management, multi-model databases, NoSQL database management systems.

CCS概念。信息系统 → 数据库设计和模型；数据模型扩展；半结构化数据；数据库查询处理；非关系引擎的查询语言；提取、转换和加载；对象关系映射设施。
附加关键词和短语。大数据管理、多模型数据库、NoSQL数据库管理系统。

---

## 1 Introduction

As data with different types and formats are crucial for the optimal business decisions, we observe the substantial increase of demands to analyze and manipulate multimodel data, including structured, semi-structured and unstructured data. In particular, structured data includes relational, key/value, and graph data. Semi-structured
data commonly refer to XML and JSON documents. Unstructured data are typically text files, containing dates, numbers and facts.

由于不同类型和格式的数据对优化商业决策至关重要，我们观察到分析和处理多模型数据的需求大幅增加，包括结构化、半结构化和非结构化数据。特别是，结构化数据包括关系数据、键/值数据和图数据。半结构化数据
数据通常指的是XML和JSON文档。非结构化数据通常是文本文件，包含日期、数字和事实。

---

We illustrate the challenge of the variety of data with three examples as follows. First, let us consider customer-360-view [Kotorov 2003] to enable a holistic analysis on customer behaviors. This application demands to analyze the information from different data sources, such as product catalog (XML or JSON documents), customer social networks (graph data), social media (unstructured data) and relational tables of customer shopping records. Second, in the context of healthcare, high volumes of data are generated by multiple data sources [Aboudi and Benhlima 2018], including electrical health records (relational data), treatment plans and lab test reports (unstructured data), and health condition parameters for real-time patient health monitoring (key/value data). Finally, an oil & Gas company [Hems et al. 2013] might generate over 1.5 TB of diverse data every day [Baaziz and Quoniam 2014]. Those data come from diverse resources, such as sensors, GPS, and other instruments, and consequently have heterogeneous formats. Therefore, the above three examples demonstrate the emerging challenges to manipulate and analyze multi-model data in complex application scenarios.

我们用以下三个例子来说明数据多样性的挑战。首先，让我们考虑客户360-view[Kotorov 2003]，以实现对客户行为的整体分析。这个应用要求分析来自不同数据源的信息，如产品目录（XML或JSON文档）、客户社交网络（图形数据）、社交媒体（非结构化数据）和客户购物记录的关系表。其次，在医疗保健的背景下，大量的数据是由多种数据源产生的[Aboudi和Benhlima 2018]，包括电健康记录（关系型数据）、治疗计划和实验室测试报告（非结构化数据）以及用于实时监测患者健康状况的健康状况参数（键/值数据）。最后，一家石油天然气公司[Hems等人，2013]每天可能会产生超过1.5TB的多样化数据[Baaziz和Quoniam，2014]。这些数据来自不同的资源，如传感器、GPS和其他仪器，因此具有异构的格式。因此，以上三个例子展示了在复杂应用场景中操作和分析多模型数据的新挑战。

---

We now exemplify the challenge of multi-model data management with a concrete small example from Ecommerce in Figure 1, which contains customers, social network and orders information with four distinct data models. Customers information are stored in a relational table – their ID, name, and credit limits. Graph data bear information about mutual relationships between the customers, i.e. who knows whom. In JSON documents each order has an ID and a sequence of ordered items, each of which includes product number, name, and price. The fourth type of data, key/value pairs, bears a relationship between customers (their IDs) and orders (their IDs).

现在我们用图1中一个电子商务的具体小例子来说明多模型数据管理的挑战，图中包含客户、社交网络和订单信息，有四个不同的数现在我们用图1中一个来自电子商务的具体小例子来说明多模型数据管理的挑战，图中包含客户、社交网络和订单信息，有四个不同的数据模型。客户信息存储在一个关系表中--他们的ID、姓名和信用额度。图形数据承载 客户之间相互关系的信息，即谁认识谁。在JSON文档中，每个订单都有一个ID和一个订单项目序列，每个项目序列包括产品编号、名称和价格。第四类数据，键/值对，承担着客户（他们的ID）和订单（他们的ID）之间的关系。

![figure1](./pic/figure1.png)

---

In these multi-model data one may be interested in a recommendation query, which returns “all product numbers ordered by a friend of a customer whose credit limit is greater than 3000”. Such a query can be evaluated using various approaches depending on the selected storage strategy. Either the data is stored in different database management systems (DBMSs) corresponding to the four data models, or the four types of data are transformed into a single format, e.g., the relational format, and stored in a relational database system. However, in the former case we need to solve the problems of (1) the installation and administration of multiple distinct systems and (2) joining data stored at distinct places. In the latter case, even though storing hierarchical or graph data in a relational DBMS is feasible, the efficiency of query evaluation is a bottleneck due to the inherent structural differences from flat relations.

在这些多模型数据中，人们可能会对一个推荐查询感兴趣，这就是 返回 "信用额度为的客户朋友所订购的所有产品编号 大于3000"。这样的查询可以根据所选择的存储策略，采用不同的方法进行评估。要么将数据存储在与四种数据模型相对应的不同的数据库管理系统(DBMS)中，要么将四种类型的数据转化为单一格式，如关系格式，并存储在关系数据库系统中。然而，在前一种情况下，我们需要解决以下问题：(1)多个不同系统的安装和管理；(2)加入存储在不同地方的数据。在后一种情况下，即使在关系型DBMS中存储分层或图形数据是可行的，但由于与平面关系的内在结构差异，查询评估的效率是一个瓶颈。

---

A third option for the above task is to employ a single multi-model DBMS to exploit advantages of both the previous solutions: (1) The data is stored in the way optimal for the particular models and (2) only a single DBMS is employed to conveniently query across all the models. In Figure 2, we show two sample queries to return the requested result for two existing multi-model databases – ArangoDB [ArangoDB 2016] and OrientDB [OrientDB 2016] respectively.1 A single data platform for multi-model data is beneficial to users by providing not only a unified query interface, but a single database platform to simplify query operations, reduce integration issues, and eliminate migration problems.

上述任务的第三种选择是采用单一的多模型DBMS来利用前面两种解决方案的优势。(1)数据的存储方式对特定的模型来说是最优的；(2)只采用一个DBMS来方便地跨所有模型查询。在图2中，我们展示了两个示例查询，分别针对现有的两个多模型数据库--ArangoDB[ArangoDB 2016]和OrientDB[OrientDB 2016]返回所要求的结果，1多模型数据的单一数据平台不仅提供了统一的查询界面，而且还提供了一个单一的数据库平台，以简化查询操作，减少集成问题，并消除迁移问题，这对用户是有利的。

![figure2](./pic/figure2.png)

---

In general, there are two existing approaches to manipulate and query multi-model data: (1) polyglot persistence and (2) multi-model databases [Lu and Holubova 2017; Lu et al. 2018a]. First, the history of polyglot persistence can be traced back to multi databases [Smith et al. 1981] and federation databases [Hammer and McLeod 1979], which were intensively studied during the 1980s. Their main strategy is to leverage different databases to store different models of data and then develop a mediator to integrate them together to answer queries. Recently, some research prototypes are developed on polyglot persistence platform. For example, DBMS+ [Lim et al. 2013] targets at embracing several processing and database platforms with a unified declarative processing. BigDAWG [Elmore et al. 2015] provides an architecture that supports for location transparency and a middleware that provides a uniform multi-island interface to run users’ queries with three different integrated systems: PostgreSQL, SciDB and Accumulo.

一般来说，现有两种方法来操作和查询多模型数据。(1)多模型持久化和(2)多模型数据库[Lu和Holubova，2017；Lu等，2018a]。首先，多模型持久化的历史可以追溯到多数据库[Smith等1981]和联盟数据库[Hammer和McLeod 1979]，这两个数据库在20世纪80年代被深入研究。他们的主要策略是利用不同的数据库来存储不同的数据模型，然后开发一个中介机构将它们整合在一起回答查询。最近，一些研究原型都是在多元持久化平台上开发的。例如，DBMS+[Lim et al. 2013]的目标是拥抱多个处理和数据库平台，进行统一的声明式处理。BigDAWG[Elmore等，2015]提供了一个支持位置透明的架构，以及一个提供统一多岛接口的中间件，以三个不同的集成系统运行用户的查询。PostgreSQL、SciDB和Accumulo。

---

The second kind of systems is to build one single database to manage different data models with a fully integrated backend to handle the system demands for performance, scalability, and fault tolerance [Lu et al. 2018b]. A framework of a fullyintegrated single management system can be traced back to the concept of ORDBMS (i.e., Object-Relational DataBase Management Systems), which borrow and adapt the object-oriented programming model into the relational databases. An ORDBMS can store and process various formats of data such as relational, text, XML, spatial and object by leveraging domain specific functions. But the salient difference between the ORDBMS and multi-model databases is that, in an ORDBMS framework, only the relational model is the first-class citizen, meaning all other models are developed on top of relational technology. But in multi-model databases, there is no indispensable model and every model is equally important. Compared with the first system of polyglot persistence, the second one manages multiple models with an integrated backend which can satisfy the growing requirements for scalability, high performance and fault tolerance. In this survey, we will focus on the second approach by building a single multi-model database. As for the first approach, interesting readers may refer to Appendix C.

第二种是建立一个单一的数据库来管理不同的系统。数据模型与全集成后台，以处理系统对性能、可扩展性和容错性的需求[Lu等，2018b]。全集成单管理系统的框架可以追溯到ORDBMS（即对象-关系数据库管理系统）的概念，ORDBMS借鉴并改造了面向对象的编程模型，融入了关系数据库。ORDBMS可以通过利用特定领域的功能来存储和处理各种格式的数据，如关系型、文本型、XML型、空间型和对象型等。但ORDBMS与多模型数据库的突出区别在于，在ORDBMS框架中，只有关系模型是第一等公民，也就是说其他模型都是在关系技术之上开发的。但在多模型数据库中，没有不可缺少的模型，每个模型都同样重要。与第一种多模型持久化系统相比，第二种多模型持久化系统通过集成后台管理多个模型，可以满足日益增长的可扩展性、高性能和容错性的要求。在本次调查中，我们将重点讨论第二种方法，通过建立一个单一的多模型数据库。至于第一种方法，感兴趣的读者可以参考附录C。



---

Main Contributions. This survey reviews the representatives of multi-model databases and summarizes their major features and techniques. The comprehensive review and analysis make this article useful for motivating new multi-model processing techniques, developing real-world multi-model database applications, as well as serving as a technique reference for selecting and comparing the existing multi-model database products. In particular, the main contributions are summed up as follows:

主要贡献。本调查报告回顾了多模型数据库的代表，总结了其主要特点和技术。通过全面的回顾和分析，使本文对于激励新的多模型处理技术、开发实际的多模型数据库应用具有一定的作用，同时也可以作为选择和比较现有多模型数据库产品的技术参考。具体来说，主要贡献总结如下。

---

(1) We introduce the area of multi-model DBMSs and their relation to other database technologies. We provide historical background as well as a general classification of related approaches.

(2) We compare the existing multi-model DBMSs from various viewpoints and using distinct criteria. We also provide the timeline depicting their evolution and reflecting the historical needs for such systems.

(3) We provide a detailed overview and description of key features of existing representatives of multi-model DBMSs. Using examples we demonstrate their basic capabilities and differences.

(4) We discuss the remaining open problems and demonstrate that multi-model databases form a challenging research area where the solutions will find exploitation in a broad range of real-world use cases.

(1)我们介绍多模型DBMS的领域及其与其他数据库的关系。技术。我们提供了历史背景和一般分类。的相关方法。

(2)我们从不同的角度对现有的多模型DBMS进行比较，用 不同的标准。我们还提供了描述其演变的时间轴，反映了对这类系统的历史需求。

(3)我们对现有的多模型DBMS代表的主要特征进行了详细的概述和描述。通过实例我们展示了它们的基本 能力和差异。

(4)我们讨论了剩余的未解决的问题，并证明多模型的 数据库是一个具有挑战性的研究领域，其解决方案将在广泛的实际使用案例中得到利用。

---

Related Work. Currently there exist several surveys dealing with efficient management and/or processing of Big Data. Paper [Sakr et al. 2015] describes existing Big Data processing systems, namely big SQL systems, graph management systems, and stream processing systems. Papers [Sakr et al. 2013; Li et al. 2014] focus on a detailed study of the MapReduce programming framework and approaches built on top of it. Considering Big Data DBMSs, there exist tens of papers which provide a general description and classification of NoSQL databases, experimental evaluations, comparative studies, and/or benchmarks of selected representatives of various types of NoSQL systems, eventually involving also relational DBMSs. For more specific studies, papers [Elshawi et al. 2015; Angles et al. 2017] survey graph DBMSs and their query languages. Paper [Cattell 2011] provides an overview and comparison of key/value, document, extensible record (i.e. column) and scalable relational DBMSs. There exists also a web page2 focusing on ranking of various types of DBMSs, including NoSQL, which ranks database management systems according to their popularity which is evaluated3 on the basis of number of mentions of the system on websites, frequency of technical discussions about the system etc. Recently, a general survey and a comparison of three multi-model databases has been published in [Płuciennik and Zgorzałek 2017]. However, to the best of our knowledge, there exists no paper solely dealing with multi-model databases in the extent and depth comparable to this survey.

相关工作。目前，有一些调查涉及大数据的高效管理和/或处理。论文[Sakr等人，2015]介绍了现有的Big 数据处理系统，即大SQL系统、图管理系统和。流处理系统。论文[Sakr等，2013；Li等，2014]主要是详细介绍了? 研究MapReduce编程框架和建立在它之上的方法。考虑到大数据DBMS，目前已有数十篇论文对NoSQL数据库进行了总体描述和分类，对各类NoSQL的选定代表进行了实验评估、比较研究和/或基准研究 系统，最终也涉及到关系型DBMS。更具体的研究，论文[Elshawi等，2015；Angles等，2017]调查了图式DBMS及其查询。语文。论文[Cattell 2011]提供了关键/价值的概述和比较。文档、可扩展记录（即列）和可扩展关系型DBMS。存在 也是一个网页2 专注于包括NoSQL在内的各种类型DBMS的排名。根据数据库管理系统的受欢迎程度对其进行排名，其中包括 根据网站上对该系统的提及次数、对该系统的使用频率，对该系统进行评估3。系统的技术讨论等。最近，在[Płuciennik和Zgorzałek]发表了对三个多模型数据库的总体调查和比较。2017]. 然而，据我们所知，目前还不存在任何一篇单纯处理 多模型数据库的范围和深度与本次调查相当。

---

It is worthy to mention the difference between multi-modal databases and multi model databases. The former means the multi-media databases where the types of data may include speech, images, videos, handwritten text and fingerprints. But the latter stands for a system to manage data with different models such as relational, tree, graph and object models. The scope of this survey restricts to the latter one, i.e. multi-model databases.

值得一提的是多模式数据库和多模型数据库之间的区别。前者指的是多媒体数据库，数据类型可能包括语音、图像、视频、手写文本和指纹。但是后者代表的是用关系模型、树模型、图模型和对象模型等不同模型来管理数据的系统。本调查的范围仅限于后一种，即多模型数据库。

---

Outline. The rest of this article is organized as follows: Section 2 presents a brief introduction of four common data models. Section 3 deals with classification and comparison of existing multi-model DBMSs from the view of both history and contemporary features. In Section 4 we provide a detailed description of particular multi-model systems. In Section 5 we discuss challenges and open problems, and finally we conclude
this article in Section 6.

纲要。本文其余部分组织如下。第2节简要介绍了四种常见的数据模型。第3节从历史和当代的角度对现有的多模型DBMS进行分类和比较的特点。在第4节中，我们对特定的多模型系统进行了详细描述。在第5节中，我们讨论了挑战和开放性问题，最后我们总结道本条第6节。

---

## 2. PRELIMINARIES ON DATA MODELS
In this section, we briefly review the four data models which are supported by most of multi-model databases, including relational, semi-structured, key/value and graph model.

关于数据模型的初步介绍。
在本节中，我们简单回顾一下大多数多模型数据库所支持的四种数据模型，包括关系型、半结构型、键/值型和图模型。

---

2.1. Relational Model
Relational model is based on the mathematical term relation, i.e. a subset of Cartesian product. The data are logically represented as tuples forming relations. Each record in a relation is uniquely identified by a key. The relational data can be both defined and queried using a declarative approach, which is currently mainly represented by the Structured Query Language (SQL) [ISO 2008]. The relational DBMS then ensures both storing and retrieving of the data. Examples of relational databases include financial and banking systems, computerized medical records, and on-line shopping.

2.1. 关系模型
关系模型是基于数学项关系，即笛卡尔积的子集。数据在逻辑上表示为构成关系的元组。关系中的每条记录都由一个键唯一标识。关系数据既可以定义并使用声明式方法进行查询，目前主要用结构化查询语言（SQL）[ISO 2008]表示。然后关系型数据库管理系统确保数据的存储和检索。关系型数据库的例子包括金融和银行系统、计算机化医疗记录和在线购物。

---

2.2. Semi-structured Model for XML and JSON Documents
The semi-structured model is based on the idea of representing the data without explicit and separate definition of its schema. Instead, the particular pieces of information are interleaved with structural/semantic tags that define their structure, nesting etc. Such a representation enables more flexible processing and exchanging of the data.In the following, we introduce two representative semi-structured data types: XML and JSON.

2.2. XML和JSON文件的半结构化模型。
半结构化模型的基础是在不明确和单独定义其模式的情况下表示数据的想法。相反，特定的信息片段被结构/语义标签交织在一起，定义其结构、嵌套等。这样的表示方式使得数据的处理和交换更加灵活.下面我们介绍两种有代表性的半结构化数据类型。XML和JSON。

---

The Extensible Markup Language (XML) [W3C 2008] is a human-readable and machine-readable markup language. Its format is textual and based on the exploitation of Unicode to enable the support of various languages. The data are expressed using elements delimited by tags which can contain simple text, subelements or their combination. Additional information can be stored in attributes of an element. XML is widely used for the representation of arbitrary data structures. such as those used in web services. The JSON (JavaScript Object Notation) [Ecma International 2013] is a human-readable open-standard format. It is based on the idea of an arbitrary combination of three basic data types used in most programming languages – key/value pairs, arrays and objects.

可扩展标记语言(XML)[W3C 2008]是一种可供人类阅读的，并且是一种可扩展的标记语言。机器可读标记语言。它的格式是文本式的，基于对Unicode的利用，以支持各种语言。数据的表达方式是 使用由标签分隔的元素，标签可以包含简单的文本、子元素或其 的组合。附加信息可以存储在元素的属性中。XML 被广泛用于任意数据结构的表示，如那些被用于 在网络服务中。JSON（JavaScript对象符号）[Ecma International 2013]是指 是一种人类可读的开放标准格式。它是基于大多数编程语言中使用的三种基本数据类型的任意组合的想法--键/值。对、数组和对象。

---

2.3. Key/value Model
The key/value model is definitely the simplest data model used in NoSQL databases. It corresponds to associative arrays, dictionaries, or hashes. Each record in the key/value model consists of an arbitrary value and its unique key which enables to store, retrieve, or modify the value. The simplicity of the model and respective operations enable efficient data processing (at the cost of non existence of a powerful query language).

2.3. 钥匙/价值模式
键/值模型绝对是NoSQL数据库中使用的最简单的数据模型。它对应的是关联数组、字典或哈希。在key/value模型中，每条记录都由一个任意值和它的唯一key组成，它可以存储、检索或修改值。该模型和相关操作的简单性使得数据处理效率很高（代价是不存在强大的查询语言）。

---

2.4. Graph Model
The graph data model is based on the mathematical definition of a graph, i.e., a set of
vertices (nodes) V and edges E corresponding to pairs of vertices from V . In the world
of Big Data there exists a special type of databases, called graph databases, devoted for efficient storage and management of the graph data. We can further distinguish two types of graph databases which correspond to two main types of graph data use cases and differ in the respective usage [Sakr and Pardede 2011]. Transactional databases work with a large set of smaller graphs, such as a set of linguistic trees or chemical compounds. The respective operations usually search for supergraphs, subgraphs, or similar graphs. Non-transactional databases conversely target a single large graph (e.g., a social network), possibly having several components. The respective operations correspond to searching a (shortest) path, communities (i.e., subgraphs with specific  features) etc.

2.4. 图形模型
图形数据模型是基于图形的数学定义，即由一组
顶点（节点）V和边E对应于V的顶点对。在这个世界上
大数据中存在一种特殊类型的数据库，称为图数据库，专门用于 图数据的高效存储和管理。我们可以进一步区分两种 图形数据库的类型，对应着两种主要的图形数据用例类型 并在各自的用法上有所不同[Sakr和Pardede，2011]。事务性数据库 与一大组较小的图形一起工作，如语言树或化学树的集合。化合物。各自的操作通常搜索超图、子图或 类似的图。非事务性数据库则相反，以单一的大图为目标。(例如，一个社交网络)，可能有几个组成部分。各项业务 对应于搜索（最短）路径，社区（即具有特定的子图的  功能）等。

---

Interested readers may refer to other excellent surveys, such as [Angles and Gutierrez 2008; Davoudian et al. 2018] for rigorous and comprehensive definitions on different data models in databases.

有兴趣的读者可以参考其他优秀的调查报告，如[Angles和Gutierrez，2008；Davoudian等，2018]关于数据库中不同数据模型的严谨而全面的定义。

---

## 3 TAXONOMY AND COMPARATIVE STUDY
Starting with a brief history of the multi-model databases, in this section we provide a comparative study of existing multi-model DBMSs.

3 税制和比较研究。
从多模型数据库的简要历史开始，本节我们将对现有的多模型DBMS进行比较研究。

---

3.1. A brief History
In the mid-1960s, data was stored in file systems. Then, in the early 1980s, relational databases began to gain commercial traction for enterprise data management mainly owing to Edgar F. Codds relational model (which was described already in 1969). Later, in 1990s, enterprises identified a need to process non-relational data in many applications and thus a number of databases were developed to focus on a special type of applications, e.g. object-oriented databases, XML databases, spatial databases, or RDF databases. Today, the evolution continues to manage Big Data and cloud applications, i.e. to write, read, and distribute large scale of different types of data everywhere. In the early 2010s, a number of NoSQL databases are created, such as Cassandra, HBase, CouchDB, OrientDB, Neo4j, Asterix, ArangoDB, or MongoDB, to name a few.

3.1. 历史简介
在20世纪60年代中期，数据被存储在文件系统中。然后，在20世纪80年代初，关系型的数据系统出现了。数据库在企业数据管理中开始获得商业化的牵引力，主要是指： 1. 由于Edgar F.Codds的关系模型(1969年已经描述过)。后来： 在20世纪90年代，企业发现在许多应用中需要处理非关系型数据，因此开发了一些数据库，专注于一种特殊类型的数据。应用，如面向对象的数据库、XML数据库、空间数据库或RDF。数据库。今天，继续进化管理大数据和云应用。即对各地不同类型的数据进行大规模的写入、读取和分发。在 2010年代初，一些NoSQL数据库应运而生，如Cassandra、HBase。CouchDB、OrientDB、Neo4j、Asterix、ArangoDB或MongoDB等等。

---

By looking back at the history of databases above, one can identify a trend that more and more types of data are stored and processed in databases. Therefore, this calls for developing a multi-model database system to have the ability to manage different kinds of data simultaneously. We can observe a recent trend among NoSQL databases in moving towards multi-model databases. There are many databases which claim to be multi-model databases currently. However, the level of support for multi-model data varies greatly, with different ability to query across distinct models, to index the internal structure of a model, and to optimize query plans across models, which will be described in details in the following sections.

通过回顾以上数据库的历史，可以发现一个趋势，那就是更多的 和更多类型的数据在数据库中存储和处理。因此，这就要求 开发一个多模型数据库系统，以便有能力管理不同的数据。种数据同时进行。我们可以观察到最近NoSQL数据库的一个趋势 在向多模型数据库发展的过程中。有许多数据库声称 目前是多模型数据库。然而，对多模型数据库的支持程度还不够。数据差异很大，不同的模型查询能力不同，要想在不同的模型中进行索引，就必须在不同的模型中进行查询。
模型的内部结构，并优化跨模型的查询计划，这将使 以下各节将详细介绍。

---

## 3.2. Taxonomy of multi-model databases
In this subsection, we discuss the taxonomy and the comparisons for diverse multi model database systems. In particular, the current multi-model databases can be classified according to various criteria. One classification on the basis of their original (or core) data model is provided in Table I. As we can see, the table involves relational databases, all four types of NoSQL databases, and other types, such as object databases. We will use this basic classification in Section 4 where we describe particular DBMSs in a more detail. In this section we focus on various other types of
classification and comparative viewpoints.

3.2. 多模型数据库的分类法
在本小节中，我们将讨论多样化的多模型数据库系统的分类方法和比较。具体来说，目前的多模型数据库可以按照不同的标准进行分类。一种分类方式是根据其原 或核心）数据模型见表一。我们可以看到，该表涉及关系型数据库、所有四种类型的NoSQL数据库以及其他类型，如对象数据库。我们将在第4节中使用这种基本分类，在这里我们将更详细地描述特定的DBMS。在本节中，我们将重点介绍其他各种类型的
分类和比较的观点。

---

First of all, in Fig. 3 we provide a timeline which depicts the journey where a system became multi-model, i.e. either when its original data format was extended towards additional ones, or when it was first released directly as a multi-model DBMS.

首先，在图3中，我们提供了一个时间轴，它描述了一个系统成为多模型的历程，即当它的原始数据格式向附加数据格式扩展时，或者当它第一次直接作为一个多模型DBMS发布时。

![tf3](./pic/tf3.png)

---

The evolution of the systems naturally corresponds to the growing popularity of particular formats. For example, we can see that the first main wave of multi-model databases has appeared soon after the beginning of the new millennium with the emergence of XML data. The key relational DBMSs were extended towards XML, usually
via the SQL/XML standard or its variation, and thus they were transformed to socalled XML-enabled databases. The second wave can be observed after 2010 with the arrival of the era of Big Data. The XML-enabled databases were often extended towards the JSON format and there have also appeared representatives of other types
of DBMSs combining their original data format with other formats.

系统的演变自然与特定格式的日益流行相对应。例如，我们可以看到，在新千年开始后不久，随着XML数据的出现，多模型数据库的第一波主潮已经出现。主要的关系型DBMS都是向XML扩展的，通常是
通过SQL/XML标准或其变体，它们被转化为所谓的XML功能数据库。第二波浪潮是在2010年之后，随着大数据时代的到来而出现的。支持XML的数据库通常向JSON格式扩展，也出现了其他类型的代表。
的DBMS将其原有的数据格式与其他格式相结合。

---

In Table II we classify the systems according to the strategy used to extend the original model to other models or to combine multiple models. We distinguish four types of approaches:

![table2](./pic/table2.png)

在表二中，我们根据将原模型扩展到其他模型或将多个模型组合起来的策略对系统进行分类。我们将四种类型的方法区分开来。

---

(1) adoption of a completely new storage strategy suitable for the new data model(s),

(2) extension of the original storage strategy for the purpose of the new data model(s),

(3) creating of a new interface for the original storage strategy, and

(4) no change in the original storage strategy.

(1) 采用适合新数据模型的全新存储战略；

(2)为了新的数据模型的目的，扩展原有的存储策略。

(3)为原来的存储策略建立新的接口，以及。

(4)不改变原有的存储策略。

---

Note that in some cases the approach can be clearly categorized, whereas mainly in case of the first and second group it is sometimes hard to decide where the particular DBMS belongs.

请注意，在某些情况下，方法可以明确分类，而主要是在第一组和第二组的情况下，有时很难决定特定DBMS的归属。

---

The typical representative of the first group are XML-enabled databases which use
a native XML approach for their efficient storing and querying. An example of the second group is a document database ArangoDB where special edge collections are used to bear information about edges in a graph. Similarly MongoDB uses for this purpose references amongst documents. An example of the third group is Sinew which builds a new layer above traditional relational storage strategy. Another example can be MarkLogic which stores JSON documents in the same way as XML documents, but adds the support for Javascript to work with the data. And, it also supports processing of JSON data using XQuery [W3C 2015b]. Examples of the fourth group are all database systems which naturally involve storage and processing of data formats simpler than the original one. Hence, for example, all document databases can also be considered as key/value and column stores. Or, all column stores can be considered as key/value stores.

第一组的典型代表是使用XML的数据库，它使用的是
的原生XML方法，以实现其高效的存储和查询。第二组的一个例子是文档数据库ArangoDB，其中使用了特殊的边缘集合。来承载图中边缘的信息。同样，MongoDB也为此使用了 文件之间的引用。第三组的一个例子是Sinew，它建立了一个 在传统的关系型存储策略之上增加了新的一层。另一个例子可以是MarkLogic，它以与XML文档相同的方式存储JSON文档，但增加了 支持Javascript来处理数据。而且，它还支持处理 JSON数据使用XQuery[W3C 2015b]。第四组的例子是所有数据库 系统，这些系统自然会涉及到数据格式的存储和处理，而这些数据格式的简单程度要高于其他系统。原始数据库。因此，例如，所有的文件数据库也可以被认为是 作为键/值和列存储。或者，所有的列存储都可以被认为是键/值。商店。

---

Next, in Table III we provide a matrix which visualizes the data models supportedin the particular multi-model DBMSs. Note that in case of the document model we consider the most common JSON format or its variants, whereas there is a separate column for the XML format which has specific features and history of support. For
the same reason we distinguish the general graph model and RDF [W3C 2014] data format. We also devote a separate column to object-like models (i.e., except for the classical object model we add here also distinct user-defined types and nested structures).The final column shows the popularity of different system on Nov. 2018 based on the statistics from the DB-Engines Ranking5

![table3](./pic/table3.png)

接下来，在表三中，我们提供了一个矩阵，该矩阵直观地显示了支持的数据模型。 在特定的多模型DBMS中。请注意，在文档模型的情况下，我们 考虑最常见的JSON格式或其变体，而有一个单独的 XML格式的列，它具有特定的功能和支持历史。对于
同样的原因，我们将一般图模型和RDF[W3C 2014]数据区分开来。格式。我们还专门用一栏来介绍类对象模型（即除了经典的对象模型外，我们在这里还加入了不同的用户定义类型和嵌套结构）。 最后一栏显示了不同系统在2018年11月的受欢迎程度，根据 DB-Engines排名的统计数据5

---

In case of the RDF model we have to point out its specific relation to this survey. Currently there exists a number of RDF triple stores. These systems are usually implemented as an extension of an existing DBMS, either as a part of it or as a module built on top of it. For example, a relational DBMS can be used as a back-end which stores RDF triples, not knowing anything about SPARQL [W3C 2013] etc. From the point of view of our survey this is not a multi-model database, but a possible use case of the respective DBMS; there is no cross-model query language, respective optimization of query evaluation etc. In this article we focus on extensions towards a new model which can be interlinked with other models supported by the DBMSs. Hence, in Table III we provide the indication of RDF support for DBMSs which are truly multi-model and which state the support for RDF directly as a part of the system. There exists a number of sources discussing various implementations of RDF support, such as, e.g. W3C wiki [W3C 2018a; 2018b] and comparative surveys focusing on triple stores [Wylotet al. 2018; Abdelaziz et al. 2017; Ozsu 2016; Sakr and Al-Naymat 2010]. We refer an interested reader to them

对于RDF模型，我们必须指出它与本次调查的具体关系。目前存在一些RDF三层存储。这些系统通常是作为现有DBMS的扩展来实现的，可以是它的一部分，也可以是建立在它之上的模块。例如，可以使用关系型DBMS作为后端，它可以存储RDF三元组，对SPARQL[W3C 2013]等一无所知。从我们调查的角度来看，这不是一个多模型数据库，而是各自DBMS可能的用例；没有跨模型查询语言，各自优化查询评估等。在本文中，我们着重于向一个新模型的扩展，它可以与DBMS支持的其他模型相互连接。因此，在表三中，我们提供了真正多模型的DBMS对RDF支持的指示，这些DBMS直接说明对RDF的支持是系统的一部分。存在许多讨论RDF支持的各种实现的来源，例如，W3C wiki[W3C 2018a；2018b]和专注于三重存储的比较调查[Wylotet al. 2018；Abdelaziz等人2017；Ozsu 2016；Sakr和Al-Naymat 2010]。我们向感兴趣的读者推荐它们



---

Tables IV, V and VI provide a closer look at the particular systems6. They overview the key characteristics of the systems divided according to their original type (i.e., relational, key/value, column etc.). In the first two tables we focus on:

![]()

![]()

![]()

表四、表五和表六提供了关于特定系统的更详细的情况。它们概述了根据其原始类型（即关系型、键/值型、列型等）划分的系统的主要特征。在前两个表格中，我们着重于：

---

(1) supported data formats,
(2) storage strategy used for the diverse data,
(3) what query language(s) it supports7, and
(4) types of indices supported for the purpose of optimization of query evaluation.

(1) 支持的数据格式；
(2)对各种数据采用的存储策略。
(3) 它支持哪些查询语言7，以及
(4)为优化查询评估而支持的索引类型。

---

In the third table we provide yes (√) / no (×) / unknown or unspecified (–) features informing:
(5) whether the database is distributed,
(6) whether the database requires schema definition for storing the data,
(7) whether the diverse data can be queried together using a single common language,
(8) whether there exists also a version for the cloud, and
(9) whether a special transaction management was introduced to handle the diverse data.

在第三张表中，我们提供了是（√）/否（×）/未知或未指明（-）的特征告知。
(5)数据库是否分布。
(6) 数据库是否需要定义存储数据的模式。
(7)是否可以使用单一的通用语言对不同的数据进行查询。
(8) 是否也有云的版本，以及
(9) 是否引入了专门的交易管理来处理各种数据。

---

Characteristics (1) and (2) have already been described, while characteristics (4) are further analyzed and discussed later in this section. Considering characteristics (3), as we can see, query languages involve various approaches, both declarative and imperative. The options range from simple API (DynamoDB), full-text search (Riak), to extensions of popular standard query languages, such as SQL (e.g., PostgreSQL, Cassandra, or OrientDB) or XQuery (MarkLogic). Naturally SQL-extensions and SQLlike languages form the main approach (we devote to this aspect a separate Table VII).

特征(1)和(2)已经介绍过了，而特征(4)将在本节后面进一步分析和讨论。考虑到特征(3)，我们可以看到，查询语言涉及各种方法，包括声明式和命令式。选择范围从简单的API(DynamoDB)、全文检索(Riak)，到流行的标准查询语言的扩展，如SQL(如PostgreSQL、Cassandra或OrientDB)或XQuery(MarkLogic)。当然，SQL扩展和类似SQL的语言构成了主要的方法（我们在单独的表七中专门讨论这方面的问题）。

---

If we have a closer look at characteristics provided in Table VI. As we can see, most of the systems support data distribution. For the NoSQL databases, especially those of type key/value regardless the complexity of the value part (i.e., including column and document DBMSs) it is quite a natural feature. However, we can find this tendency also amongst other types of systems which reflects the general need for Big Data management. Flexible schema is not that common feature in general although we can find it, for example, also amongst relational databases which do not require schema for JSON or XML data. For NoSQL databases it is usually a common feature. Queries across multiple models are a kind of a must in multi-model databases, so most of the systems support them. In some cases, however, this information is unknown or irrelevant, depending on the type of the system. On the other hand, we have not managed to find any explicit information about existence of a special type of transaction management across diverse data models. This feature is however highly related to the way the system was extended towards multiple data models. Regarding cloud computing, we can witness a strong tendency of the DBMSs vendors towards the support of a version for the cloud. Again, this corresponds to the general trend in Big Data management, where the DaaS (Database as a Service) approach enables to create a solution for complex Big Data applications instantly.

如果我们仔细看一下表六提供的特征。我们可以看到，大多数 的系统支持数据分发。对于NoSQL数据库，特别是那些键/值类型的数据库，无论值部分的复杂程度如何（即，包括列和文档DBMS），这是一个非常自然的特征。然而，我们可以在其他类型的系统中发现这种趋势，这反映了大数据管理的普遍需求。尽管我们可以在关系型数据库中找到灵活的模式，但一般来说，灵活的模式并不是很常见的特征，例如，在不需要JSON或XML数据模式的关系型数据库中。对于NoSQL数据库来说，它通常是一个常见的特性。在多模型数据库中，跨多个模型的查询是一种必须的功能，所以大多数的系统都支持这种功能。然而，在某些情况下，这些信息是未知的或无关的，这取决于系统的类型。另一方面，我们还没有找到任何明确的信息，说明在不同的数据模型中存在一种特殊类型的事务管理。然而，这一特征与系统向多种数据模型扩展的方式高度相关。关于云计算，我们可以看到DBMSs厂商对云计算版本支持的强烈倾向。同样，这也符合大数据管理的总体趋势，DaaS（数据库即服务）方法能够为复杂的大数据应用即时创建解决方案。

Table VII is devoted to the overview of SQL extensions and SQL-like languages used in multi-model DBMSs. Again the systems are classified according to their original type in order to show that this probably most common and with regards to the popularity of SQL also logical approach can be found in all types of multi-model databases. At first sight, the least natural usage of SQL-like interface can probably be found amongst graph and document DBMSs. However, in this case the SQL clauses are simply extended towards the access of more complex data structures – in case of graph data the dot notation represents the edges, in case of nested document (JSON) data various operators enable to access deeper data levels including items of arrays. It is especially interesting to compare the latter approach with the way SQL/XML combines the access to relational and XML data via embedding XQuery.

表七专门介绍了所使用的SQL扩展和类SQL语言的概况。在多模型DBMS中。同样，系统也是根据其原有的 类型，以表明这可能是最常见的，关于SQL的普及，也可以在所有类型的多模型数据库中找到逻辑方法。乍一看，类似SQL的界面最不自然的用法可能是以下几种 在图和文档DBMS中。然而，在这种情况下，SQL子句只是简单地扩展了对更复杂的数据结构的访问--在图式数据库的情况下 data中的点符号表示边缘，在嵌套文档（JSON）的情况下，data 各种操作符可以访问更深层次的数据，包括数组的项目。比较后一种方法与SQL/XML结合的方式是特别有趣的。通过嵌入XQuery来访问关系型和XML数据。

---

Last but not least, in Table VIII we provide a summary of query optimization strategies used in the multi-model databases for the “non-native” formats. As expected, the most common type of query optimization is a kind B-tree/B+-tree index, especially in the case of relational databases which naturally exploit their most common and verified approach. Systems which support XML data also exploit a kind of native XML index, most commonly an ORDPATH-based approach which enables both efficient querying and data updates. A kind of hashing, a technique which can be used almost universally, is also a common approach in various types of DBMSs. However, in general there seems to be no universally acknowledged optimal or sub-optimal approach suitable for the multi-model query optimization. The distinct approaches are usually highly related to the way the system was extended towards other data models.

最后但并非最不重要的是，在表八中，我们提供了多模型数据库中使用的 "非本地 "格式的查询优化策略的总结。如同预期的那样，最常见的查询优化类型是一种B-tree/B+-tree索引，特别是在关系型数据库的情况下，它自然会利用其最常见和经过验证的方法。支持XML数据的系统也会利用一种原生XML索引，最常见的是基于ORDPATH的方法，它可以实现高效查询和数据更新。一种哈希，一种几乎可以普遍使用的技术，也是各种类型的DBMS中常见的方法。然而，在一般情况下，似乎没有公认的适合多模型查询优化的最优或次优方法。不同的方法有 通常与该系统向其他数据模型扩展的方式有很大关系。

---

Summary. From the preceding discussion with regard to the varied aspects of multimodel databases, we summarize the observations in the following:

总结。根据前面关于多模型数据库各方面的讨论，我们将观察结果总结如下。

---

The data models supported by multi-model databases include relational, column, key/value, document, XML, graph, and object.

Multi-model databases employ cross-model languages based on the extension of SQL, XML, and graph languages. 

The data indices in multi-model databases include inverted index, B-tree, materialized view, hashing, and bitmap index. Most of them are based on an extension for relational or XML databases.

The existing multi-model databases have the features of data sharding, flexible schema, and a version for cloud. But they still lack of the support for multi-model transactions.

多模型数据库支持的数据模型包括关系型、列型、键/值型、文档型、XML型、图型和对象型。

多模型数据库采用基于SQL、XML和图语言扩展的跨模型语言。

多模型数据库中的数据索引包括倒置索引、B-树、物化视图、哈希和位图索引。它们大多是基于关系数据库或XML数据库的扩展。

现有的多模型数据库具有数据分片、灵活 模式，以及云计算的版本。但他们仍然缺乏对多模型的支持。交易；

## 4 A CLOSER LOOK AT MULTI-MODEL DATABASE REPRESENTATIVES


In this section we explore in more detail different multi-model databases using the classification introduced at the beginning of Section 3. For each category we briefly describe key features of each of the representatives. We focus mainly on the aspects related to multi-model data management classified in the previous section. The aim is to provide the readers with a detailed look at each of the systems in the context of its competitors.

仔细研究多模型数据库代表。
在本节中，我们利用第3节开头介绍的分类方法，更详细地探讨不同的多模型数据库。对于每一个类别，我们简要介绍一下
描述每个代表的主要特点。我们主要关注上一节中分类的多模型数据管理的相关方面。目的是让读者在竞争者的背景下详细了解每个系统。

---

### 4.1. Relational Stores
One of the biggest sets of multi-model systems is naturally formed by relational stores.
This is given by several reasons:
(1) Historically relational DBMSs are the most popular type of databases.
(2) The SQL standard has been extended towards other data formats (e.g., XML in SQL/XML) even before the arrival of Big Data and NoSQL DBMSs.
(3) The simplicity and universality of the relational model enables its extension towards other data models relatively easily.

4.1. 关系商店
多模型系统中最大的一组自然是由关系存储形成的。
这是由以下几个原因给出的。
(1)历史上关系型DBMS是最流行的数据库类型。
(2)在大数据和NoSQL DBMS到来之前，SQL标准就已经向其他数据格式扩展(如SQL/XML中的XML)。
(3)关系模型的简单性和通用性使其能够比较容易地扩展到其他数据模型。

---

PostgreSQL. The development of PostgreSQL8 began in the mid-1980s aiming at a classical relational DBMS. The recent versions, however, bring many NoSQL features (like, e.g., materialized views enabling data duplicities for faster query evaluation or synchronous and asynchronous master-slave replication). There also exists a number of vendors of facilities to make it easy to set up, operate and scale PostgreSQL deployments in the cloud.

PostgreSQL。PostgreSQL8的开发始于20世纪80年代中期，目标是一个经典的关系型DBMS。然而，最近的版本带来了许多NoSQL的特性（例如，物化视图可以实现数据重复以加快查询评估或同步和异步主从复制）。此外，还存在一些供应商的设施，使其能够轻松地设置、操作和扩展PostgreSQL在云中的部署。

---

Following the support of the XML format, since 2006 it supports also storing of key/value pairs9 in data type HStore. And since 2013 it supports storing of the JSON format in data types json and jsonb. In the former case an exact copy of the data is stored and it must be re-parsed on each access. Also not all operations are supported for data type json (such as containment and existence operators). In case of jsonb a decomposed binary format is used for data storage. It does not require re-parsing and supports indexing. However, the order of object keys, white space, and duplicate object keys are not preserved. The primitive types are mapped to native PostgreSQL types.

在支持XML格式之后，自2006年起，它还支持存储以下信息 键/值对9 在数据类型HStore中。并且自2013年起，它支持存储JSON 格式的数据类型json和jsonb。在前一种情况下，数据的确切副本是 存储，而且每次访问都必须重新进行解析。另外，并非所有的操作都支持 (如包含和存在运算符)。对于jsonb来说，一个 分解的二进制格式用于数据存储。它不需要重排和 支持索引。但是，对象键的顺序、空白空间和重复的对象 键不被保存。基元类型被映射到本地PostgreSQL类型。

---

Both json and jsonb types can be used as other data types of PostgreSQL, such as in definition of table columns. There is no checking of schema of the stored JSON data; however, the documentation naturally recommends the JSON documents to have a somewhat fixed structure within a particular set stored at one place. An example of storing both relational and JSON data in PostgreSQL can be seen in Fig. 4.

json和jsonb类型可以作为PostgreSQL的其他数据类型使用，例如在定义表列时。没有对存储的JSON数据的模式进行检查，但是，文档自然建议JSON文档在一个地方存储的特定集合中具有一定的固定结构。在PostgreSQL中同时存储关系型数据和JSON数据的例子可以在图4中看到。

---

Data stored in PostgreSQL data types json or jsonb can be queried using an SQL extension for JSON involving operators for getting an array element by index (->int), an object field by key (->string), or an object at a specified path (#>text[]).10 Standard comparison operators are available only for jsonb. It also supports further operators like containment of values/paths in both directions (@> and <@), top-level key-existence for a string, any of the strings, or all of the strings (?, ?& and ?|), concatenation (||), and deleting either a key/value pair or a string element (-text), an array element with specified index (-int), or a field or element with specified path (#-text[]). PostgreSQL also provides functions for JSON creation, returning the length of an array, JSON object/array expansion, checking data types, transforming JSON data to records, or JSON data aggregation. An example of querying both relational and JSON data (defined in Fig. 4) can be seen in Fig. 5.

存储在PostgreSQL数据类型json或jsonb中的数据可以使用JSON的SQL扩展进行查询，其中包括通过索引(->int)获取数组元素、通过键(->string)获取对象字段、或通过指定路径(#>text[])获取对象的运算符。它还支持更多的运算符，如双向包含值/路径(@>和<@)，一个字符串、任何一个字符串或所有字符串的顶层键存在(?、?&和?|)，连接(||)，以及删除键/值对或字符串元素(-text)、指定索引的数组元素(-int)或指定路径的字段或元素(#-text[])。PostgreSQL还提供了创建JSON、返回数组长度、JSON对象/数组扩展、检查数据类型、将JSON数据转换为记录或JSON数据聚合的函数。图5中可以看到一个同时查询关系型数据和JSON数据的例子（定义在图4中）。

---

Data stored in jsonb can be indexed using the Generalized Inverted Index (GIN) corresponding to a set of pairs (key, posting list). GIN consists of a “B-tree index constructed over keys, where each key is an element of one or more indexed items and where each tuple in a leaf page contains either a pointer to a B-tree of heap pointers (posting tree), or a simple list of heap pointers (posting list) when the list is small enough”.

存储在jsonb中的数据可以使用对应于一组对（key、posting list）的通用反转索引（GIN）进行索引。GIN由 "在键上构造的B树索引，其中每个键是一个或多个索引项的元素，叶页中的每个元组包含一个指向堆指针的B树的指针（posting tree），或者当列表足够小时，包含一个简单的堆指针列表（posting list）"。

---

By default the GIN index supports top-level key-exists operators (?, ?& and ?|, for a single string, all given strings, or any of the given strings respectively) and path/value containment operator @>. Non-default GIN index supports only operator @>. The difference is that in case of default indexing for each key and value an independent index item is created. In case of non-default indexing for each value an index item is created as a hash of the value and all the related key(s).

默认情况下，GIN索引支持顶层的键存在运算符(?、?&和?|，分别用于单个字符串、所有给定字符串或任何给定字符串)和路径/值包含运算符@>。非默认的GIN索引只支持操作符@>。不同的是，在默认索引的情况下，每个键和值都会创建一个独立的索引项。在非默认索引的情况下，每个值都会创建一个索引项，作为该值和所有相关键的哈希。

---

SQL Server. Microsoft SQL Server11 started in late 1980s as a relational DBMS. Since 2000 it supports XML and its access using SQLXML [Microsoft 2017c] (a deprecated Microsoft version of SQL extension for XML data), and thus is classified as an XML-enabled database. Since 2016 it supports also the JSON format [Popovic 2015], whereas the work with JSON data is quite similar to XML support. JSON data can be stored as a pure text in data type NVARCHAR. Or, function OPENJSON enables one to transform JSON text to a relational table, either with a pre-defined schema and mapping rules (JavaScript-like paths to JSON data), or without a schema as a set of key/value pairs.

SQL Server。微软SQL Server11开始于20世纪80年代末，是一个关系型DBMS。自2000年以来，它支持XML及其使用SQLXML[Microsoft 2017c]的访问(微软对XML数据的SQL扩展的一个废弃版本)，因此被归类为一个 支持XML的数据库。自2016年起，它还支持JSON格式[Popovic 2015]。而JSON数据的工作则与XML的支持十分相似。JSON数据可以是 以数据类型NVARCHAR的纯文本形式存储。或者，函数OPENJSON使人们能够将JSON文本转换为关系表，或者使用预先定义的模式和映射来转换。规则（类似JavaScript的JSON数据路径），或者没有模式作为一组键/值的 对。

---

In addition, thanks to Polybase [Microsoft 2017b], SQL Server 2016 can be considered also as a multi-model multi-database DBMS. Polybase is a technology that accesses both non-relational and relational data. In particular, it allows one to run SQL queries on external data in Hadoop12 or Azure blob storage13. Microsoft Azure SQL database is a cloud database providing SQL Server functionality.

此外，由于Polybase[Microsoft 2017b]的存在，SQL Server 2016也可以被认为是一个多模型多数据库的DBMS。Polybase是一种既能访问非关系型数据又能访问关系型数据的技术。特别是，它允许人们在Hadoop12或Azure blob存储13中的外部数据上运行SQL查询。Microsoft Azure SQL数据库是一个提供SQL Server功能的云数据库。

---

Regarding querying, SQLXML has the same aim as SQL/XML, but different syntax. [Holubova and Necasky 2009] Construct OPENXML enables to view XML data as SQL relations using a mapping which can be utilized using user-defined parameters. Construct FOR XML enables to view relational data as XML documents using four predefined modes denoting the complexity of the hierarchical structure.

关于查询，SQLXML的目的与SQL/XML相同，但语法不同。Holubova和Necasky 2009] Construct OPENXML可以通过使用用户定义参数的映射将XML数据看作是SQL关系。Construct FOR XML可以使用四种预定义的模式将关系数据作为XML文档查看，这四种模式表示了层次结构的复杂性。

---

In case of JSON data, SQL Server enables to export relational data in the JSON format (using clause FOR JSON), test whether a text value is in the JSON format (using function ISJSON), or parse a JSON text and on the specified JavaScript-like path extract a scalar value (using function JSON VALUE) or an object/array (using clause JSON QUERY). Function JSON MODIFY enables one to update the value of a property.

如果是JSON数据，SQL Server可以导出JSON格式的关系数据（使用子句FOR JSON），测试文本值是否为JSON格式（使用函数ISJSON），或者解析一个JSON文本，并在指定的类似JavaScript的路径上提取一个标量值（使用函数JSON VALUE）或一个对象/数组（使用子句JSON QUERY）。功能JSON MODIFY使人们能够更新一个属性的值。

---

Columns with XML data type can be indexed too. Using the ORDPATH schema [O’Neil et al. 2004] all tags, values and paths in the stored XML data are indexed within the primary XML index. Secondary indices can be created as well – a B+ tree can be built over pairs (path, value), tuples (primary key of base table, path, value), or pairs (value, path).

XML数据类型的列也可以进行索引。使用ORDPATH模式[O'Neil等人，2004]，存储的XML数据中的所有标记、值和路径都在主XML索引中进行索引。也可以创建二级索引--可以在对（路径、值）、元组（基表的主键、路径、值）或对（值、路径）上建立B+树。

---

For the purpose of query optimization SQL Server does not support any special indexing technique for JSON data. Depending on its storage, either B-tree or full-text indices can be used.

出于查询优化的目的，SQL Server不支持对JSON数据采用任何特殊的索引技术。根据其存储情况，可以使用B-树或全文索引。

---

IBM DB2. The first release of object-relational DBMS IBM DB214 dates back to early 1980s. IBM Db2 on Cloud is a fully managed database on cloud. Since 2007 it provides a support for XML (using the native XML storage feature called pureXML [Saraccoetal. 2006]) and since 2012 it supports also RDF graphs (using extension called DB2RDF [Bornea et al. 2013]).

IBM DB2。对象关系型DBMS IBM DB214的第一个版本可以追溯到20世纪80年代初。IBM Db2 on Cloud是一个云上的全面管理数据库。自2007年起，它提供了对XML的支持（使用称为pureXML的本地XML存储功能[Saraccoetal.2006]），自2012年起，它还支持RDF图（使用称为DB2RDF的扩展[Bornea等人2013]）。

---

XML data are stored [IBM Knowledge Center 2017b] in native XML data type columns in a parsed format reflecting the hierarchical structure, or using user-defined shredding into relational tables. The data are accessed [IBM Knowledge Center 2017a] using standard SQL/XML enhanced with several DB2-specific constructs, such as, e.g., embedding SQL queries to XQuery expressions.

XML数据[IBM知识中心2017b]以反映层次结构的解析格式存储在原生的XML数据类型列中，或者使用用户定义的粉碎方式存储到关系表中。使用标准的SQL/XML访问数据[IBM知识中心2017a]，这些标准的SQL/XML通过一些DB2特定的构造得到增强，例如，将SQL查询嵌入到XQuery表达式中。

---

In case of the XML data type DB2 supports several types of XML indices. [Holubova and Necasky 2009] The location (i.e., regions of storage) of each XML document is automatically stored in the XML region index. Unique XML paths and their IDs are indexed automatically in the XML column path index. Query performance can be increased using user-defined XML index for selected XPath [W3C 2015a] expressions.

在XML数据类型的情况下，DB2支持几种类型的XML索引。Holubova和Necasky 2009]每个XML文档的位置（即存储的区域）自动存储在XML区域索引中。独特的XML路径和它们的ID会自动在XML列路径索引中建立索引。使用用户定义的XML索引可以提高查询性能，用于选定的XPath[W3C 2015a]表达式。

---

Oracle DB. Object-relational DBMS Oracle DB15 was released in 1979 as the first commercial RDBMS based on SQL. Oracle8 was released in 1997 as the objectrelational database. Oracle9i, released in 2001, introduced the ability to store and query XML. Oracle12c, released in 2013, was designed for the cloud, featuring an inmemory column store and support for JSON documents as well as RDF data (thanks to the Oracle Graph module).

Oracle DB。对象关系型DBMS Oracle DB15作为第一个基于SQL的商用RDBMS于1979年发布。1997年发布的Oracle8是对象关系型数据库。2001年发布的Oracle9i，引入了存储和查询XML的功能。2013年发布的Oracle12c是为云计算而设计的，其特点是具有内存列存储功能，并支持JSON文档以及RDF数据（得益于Oracle Graph模块）。

---

XML data are stored similarly and in the case of DB2, i.e., either shredded into tables or in a native XML data type XMLType without the need to use the schema (but the validity can be checked if required). On the other hand, JSON data is stored as textual/binary data using VARCHAR2, BLOB (preferred, since it obviates the need for any character-set conversion), or CLOB. Also in this case a schema of the data is not required. Oracle only recommends to use the is json CHECK constraint.

XML数据的存储方式与DB2类似，在DB2的情况下，即要么碎成表，要么以原生的XML数据类型XMLType存储，而不需要使用模式（但如果需要，可以检查其有效性）。另一方面，JSON数据使用VARCHAR2、BLOB（首选，因为它避免了任何字符集转换的需要）或CLOB存储为文本/二进制数据。同时在这种情况下，不需要数据的模式。Oracle只推荐使用is json CHECK约束。

---

XML data are in Oracle DB accessed using standard SQL/XML. For the purpose of accessing JSON data Oracle extends SQL with SQL/JSON functions (json value for selecting a scalar value, json query for selecting one or more values, json table for projecting JSON data to a virtual table), conditions (json exists, is (not) json, json textcontains), as well as a dot notation which acts similarly to a combination of json value and json query [Oracle 2017].

XML数据在Oracle DB中使用标准SQL/XML访问。为了访问JSON数据，Oracle对SQL进行了扩展，增加了SQL/JSON函数（json value用于选择一个标量值，json query用于选择一个或多个值，json table用于将JSON数据投射到一个虚拟表中）、条件（json exists，is（not）json，json textcontains），以及一个点符号，其作用类似于json value和json query的组合[Oracle 2017]。

---

In case of XML data shredded into object-relational tables a B-tree index can be naturally used. For native XML storage the XMLIndex indexes paths, values, and relations parent-child, ancestor-descendant, and sibling. A variant of the ORDPATH numbering schema is exploited for storing positions of nodes.

在XML数据碎成对象关系表的情况下，自然可以使用B树索引。对于原生的XML存储，XMLIndex索引的路径、值以及父子、祖先-后代和兄弟姐妹的关系。ORDPATH编号模式的一个变体被用来存储节点的位置。

---

​	can be created for SQL function json value. For XML data it is denoted as deprecated.

可以为SQL函数json值创建。对于XML数据，它被表示为废弃的。

---

MySQL. Open-source relational DBMS MySQL16 was released in 1995. In 2008 it was acquired by SUN Microsystems and in 2010 by Oracle. In 2014 the first version of MySQL cluster enabling data sharding and replication was released. With the support of Memcached API17 (since 2011) it enables to combine relational and key/value data access advantages. By default, pairs (key, value) are stored in the same table, i.e. no schema has to be defined. User-defined key prefix can however determine a pre-defined table and column where the value should be stored. [Keep 2011] Most MySQL indices are stored in B-trees, R-trees are used for spatial data types, MEMORY tables support hash indices.

MySQL。开源关系型DBMS MySQL16于1995年发布。在2008年，它 被SUN Microsystems收购，2010年被甲骨文收购。2014年，第一个版本的 发布了支持数据共享和复制的MySQL集群。随着支持 的Memcached API17（自2011年起），它可以结合关系数据和键/值数据 访问优势。默认情况下，对（键、值）存储在同一个表中，即没有 模式必须被定义。然而，用户定义的键前缀可以确定一个预先定义的? 表和列的值应该被存储。[保持2011年]大多数MySQL索引 用B树存储，R树用于空间数据类型，MEMORY表支持 哈希指数。

---

Sinew. The DBMS Sinew [Tahara et al. 2014] is based on the idea of creating a new layer above a traditional relational DBMS that enables to query multi-model data (key/value, relational, nested document etc.) without a pre-defined schema. A logical view of the data is provided to the user in the form of a universal table. Columns of the table correspond to unique keys in the dataset (nested data is flattened).

Sinew。DBMS Sinew[Tahara et al. 2014]是基于在传统的关系型DBMS之上创建一个新层的想法，它能够在没有预定义模式的情况下查询多模型数据（键/值、关系型、嵌套文档等）。数据的逻辑视图以通用表的形式提供给用户。该表的各列对应于数据集中的唯一键（嵌套数据是扁平化的）。

---

