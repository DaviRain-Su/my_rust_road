# è¯­æ³•é¢é¢è§‚ï¼š è¯æ³•ç»“æž„

- ä¸¤å¤§çŸ¥è¯†ç‚¹
    - Rustè¯­è¨€ç‰ˆæœ¬è¯´æ˜Ž
    - Rustè¯æ³•ç»“æž„

- Rust è¯­è¨€çš„ç‰ˆæœ¬è¯´æ˜Ž
    - Rustè¯­è¨€çš„ç‰ˆæœ¬åŒ…æ‹¬ä»¥ä¸‹ä¸‰ä¸ªç›¸äº’æ­£äº¤çš„æ¦‚å¿µ
        - è¯­ä¹‰åŒ–ç‰ˆæœ¬(Sem Ver, Semantic Versioning)
        - å‘è¡Œç‰ˆæœ¬
        - Edition ç‰ˆæ¬¡

    - è¯­ä¹‰åŒ–ç‰ˆæœ¬(Sem Ver, Semantic Versioning)
        - å…¶æ ¼å¼ä¸ºï¼šä¸»ç‰ˆæœ¬å·.æ¬¡ç‰ˆæœ¬å·.ä¿®è®¢å·ï¼Œä¾æ¬¡ç”¨å¥ç‚¹éš”å¼€ã€‚
        - ç®€å•è¯´ä¸€ä¸‹è¯­ä¹‰ç‰ˆæœ¬å·é€’å¢žè§„åˆ™ï¼š
            - ä¸»ç‰ˆæœ¬å·ï¼šå½“åšäº†ä¸å…¼å®¹çš„APIä¿®æ”¹
            - æ¬¡ç‰ˆæœ¬å·ï¼šå½“åšäº†å‘ä¸‹å…¼å®¹çš„åŠŸèƒ½æ€§æ–°å¢ž
            - ä¿®è®¢å·ï¼šå½“åšäº†å‘ä¸‹å…¼å®¹çš„é—®é¢˜ä¿®æ­£

    - å‘è¡Œç‰ˆæœ¬
        - master -> Nightly
        - beta -> Beta
        - stable -> Stable
    
    - Edition ç‰ˆæ¬¡
        - 2015 Edition
        - 2018 Edition 
        - 2021 Edition
    
- è¯æ³•ç»“æž„
    - äº†è§£Rustç¼–è¯‘è¿‡ç¨‹ ï¼ˆè¯æ³•åˆ†æž è¯­æ³•è§£æžï¼‰
        - åˆ†è¯ Rust Code
        - è§£æž Tokens 
        - é™çº§ AST ï¼ˆRustè¿™é‡Œçš„ä¸€ä¸ªç‰¹è‰²ä¸ä¼šåœ¨è¿™é‡Œç›´æŽ¥ç”Ÿæˆå­—èŠ‚ç æˆ–è€…æœºå™¨ç ï¼‰
        - HIR é™çº§ ï¼ˆè¿™é‡Œç‰ˆæ¬¡çš„æ¦‚å¿µå·²ç»æ²¡æœ‰äº†ï¼‰å¯¹ä»£ç è¿›è¡Œç±»åž‹æ£€æŸ¥ï¼Œæ–¹æ³•æŸ¥æ‰¾
        - MIR ä¼˜åŒ– å€Ÿç”¨æ£€æŸ¥ ä»£ç ç”Ÿæˆ  ä¼˜åŒ– å•æ€åŒ–
        - LLVM IR ä¼˜åŒ–
        - binary

    - å…­å¤§è¯æ³•ç»“æž„
        - å…³é”®å­— (keywords)
            - ä¸¥æ ¼å…³é”®å­— (strict)
                - as break const continue crate if else struct enum true false fn for in let loop impl mod match move mut pub ref return  self Self static super trait type unsafe use where while async await dyn main

            - ä¿ç•™å­— (reserved)
                - abstract become box do final macro override priv typeof unsized virtual yield try
                - è¢«ä¿ç•™çš„å…³é”®å­—ä¸ä»£è¡¨å°†æ¥ä¸€å®šä¼šè¢«ä½¿ç”¨

            - å¼±å…³é”®å­— (weak)
                - 2018 Edition: union, 'static
                - 2015 Edition: dyn
                - è¢«ä¿ç•™çš„å…³é”®å­—ä¸è¾¾æ ‡ä¸€å®šä¼šè¢«ä½¿ç”¨
        
        - æ ‡è¯†ç¬¦ (identifier)
            ```Rust 
            let thinking = "thinking"
            let thinking123_ = "thinking 123";
            
            // error: invalid suffix "thinking" for integer literal
            // let 321_thinking = "thinking";
            
            // let 321_thinking = "thinking"; // error
            let _321_thinking = "thinking";
            
            // non-ascii ident
            // error: unkown start of token: \u{1f914}
            // let ðŸ˜ = "thinking"; // error
            ```
        - æ³¨é‡Š (Comment)
          
        - ç©ºç™½ (whitespace)
          - Rustä¸­çš„ç©ºç™½å­—ç¬¦åŒ…æ‹¬ï¼š \n, \t, tabç­‰ã€‚
          - ä»»ä½•å½¢å¼çš„ç©ºç™½å­—ç¬¦åœ¨Rustä¸­åªç”¨äºŽåˆ†éš”æ ‡è®°ï¼Œæ²¡æœ‰è¯­ä¹‰æ„ä¹‰ã€‚
        - è¯æ¡ (tokens)
          - è¯­è¨€é¡¹ item
          - å— block
          - è¯­å¥ stmt
          - è¡¨è¾¾å¼ Expr
          - æ¨¡å¼ Pattern
          - å…³é”®å­— Keyword
          - æ ‡è¯†ç¬¦ Ident
          - å­—é¢é‡ Literal
          - ç”Ÿå‘½å‘¨æœŸ Lifetime
          - å¯è§æ€§ Vis
          - æ ‡ç‚¹ç¬¦å· Punctuation
          - åˆ†éš”ç¬¦ delimiter
          - è¯æ¡æ ‘ Token Tree
          - å±žæ€§ Attribute
          ```rust
            macro_rules! calculate {
                (eval $e:expr) => {{
                    {
                        let val: usize = $e; // Force type to be integers
                        println!("{} = {}", stringify!{$e}, val);
                    } 
                }};
            }
            #[test]
            fn test_calculate() {
                calculate! {
                    eval 1 + 2 // this 'eval' is not a Rust keyword!
                }
                calculate! {
                    eval (1 + 2) * (3 / 4)
                }
            }
          ```
        - è·¯å¾„ (path)



