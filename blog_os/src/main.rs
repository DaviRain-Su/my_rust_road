/// # 独立可执行程序
///
/// 创建一个不链接标准库的Rust可执行文件，将是我们迈出的第一步。无需底层操作系统的支撑，这样
/// 才能在裸机上运行Rust代码。
///
/// ## 简介
///
/// 要编写一个操作系统内核，我们需要编写不依赖任何操作系统特性的代码，这意味着我们不能使用线程
/// 、文件、堆内存、网络、随机数、标准输出，或其他任何需要操作系统抽象和特定硬件的特性；
/// 因为我们正在编写自己的操作系统和硬件驱动。
///
/// 实现这一点，意味着我们不能使用Rust标准库的大部分;但还有很多Rust特性是我们依然可以使用的。
/// 比如说，我们可以使用迭代器、闭包、模式匹配、Option、Result、字符串格式化，当然还有所有权系统。
/// 这些功能让我们能够编写表达性强、高层抽象的操作系统，而无需关心未定义行为和内存安全。
///
/// 为了用Rust编写一个操作系统内核，我们需要创建一个独立于操作系统的可执行程序。这样的可执行程序常常被称
/// 作独立式可执行程序或裸机程序。
///
/// 这里将逐步地创建一个独立式可执行程序，并且详细解释为什么每个步骤都是必须的。
///
/// ## 禁用标准库
///
/// 在默认情况下，所有的Rust包都会链接标准库，而标准库依赖于操作系统功能，如线程、文件系统、网络。标准库还与
/// Rust的C标准库实现库libc相关联，它也是和操作系统紧密交互的。既然我们的计划是编写自己的操作系统，我们就需要
/// 不使用任何与操作系统相关的库 --- 因此我们必须禁用标准库自动引用， 使用no_std属性可以实现这一点。
///
/// 创建一个项目
///
/// cargo new blog_os
///
/// 这里的项目名字为blog_os, cargo默认添加--bin选项，说明这里创建的是一个可执行文件，而不是一个库。
/// cargo还添加了 --edition 2018标签，指明项目的包要使用Rust的2018版次。
///
/// Cargo.toml 文件包含了包的配置，比如包的名称，作者，semver版本和项目依赖项；src/main.rs文件包含包的根模块
/// 和main函数，我们可以使用cargo build 来编译这个包，然后在target/debug文件夹内找到编译器好的blog_os
/// 二进制文件。
///
/// # no_std属性
///
/// 现在我们的包依然隐式地与标准库链接，为了禁用这种 链接，我们可以尝试no_std属性：
///
/// ```
/// #![no_std]
///
/// fn main(){
///    println!("Hello, World!");
/// }
/// ```
/// 当我们使用cargo build来编译的时候，却出现了下面的错误：
/// error: cannot find 'println!' in this scope
///
/// 出现这个错误的原因是println!宏是标准库的一部分，而我们的项目不再依赖于标准库，我们选择不再打印字符串，
/// 因为println！将会向标输出打印字符，它依赖于特殊的文件描述符，而这是由操作系统提供的特性。
///
/// ```
/// //main.rs
///
/// #![no_std]
///
/// fn main() {}
/// ```
///
/// cargo build
/// error : '#[panic_handler]' function required, but not found
/// error : language item required, but not found : 'eh_personality'
///
///
/// 可以发现的是，编译器缺少一个#[panic_handler]函数和一个语言项
///
/// ## 实现pani处理函数
///
/// panic_handler属性定义了一个函数，他会在一个panic发生时被调用。标准库中提供了自己的panic处理函数，
/// 但在no_std环境中，我们需要定义一个自己的panic处理函数：
///
/// ```
///
/// // in main.rs
///
/// use core::panic::PanicInfo;
///
/// // 这个函数将在panic时被调用
/// #[panic_handler]
/// fn panic(_info: &PanicInfo) -> ! {
///     loop {}
/// }
/// ```
/// 类型为PanicInfo的参数包含了panic发生的文件名、代码行数和可选的错误信息。
/// 这个函数从不返回，所以它被标记为发散函数， 发散函数的返回类型称做Never类型， 即为！.
/// 对于这个函数，目前能做的很少，所以只需编写一个无线循环loop {}
///
/// ## eh_personality 语言项
///
/// 语言项是一些编译器需求的特殊函数或类型。举例来说，Rust的Copy trait就是一个这样的语言项，告诉编译器
/// 哪些类型需要遵循复制语义 -- 当我们查找Copy trait 的实现时，我们会发现，一个特殊的#[lang = "Copy"]
/// 属性将它定义为一个语言项，达到与编译器联系的目的。
///
/// 我们可以自己实现语言项，但这是下下策：目前来看，语言项是高度不稳定的语言细节实现，他们不会经过编译期
/// 类型检查（所以编译器甚至不确保它们的参数类型是否正确）。幸运的是，我们有更稳定的方式，来修复上面的语言项错误。
///
/// eh_personality 语言项标记的函数，将被用于实现栈展开。在使用标准库的情况下，当panic发生时，Rust将使用栈
/// 展开，来运行在栈上所有活跃的变量的析构函数 --- 这确保了所有使用的内存都被释放，允许调用程序的父进程捕获panic,
/// 处理并继续运行。但是,栈展开是一个复杂的过程，如linux的libunwind或windows的结构化异常处理，通常需要依赖于
/// 操作系统的库；所以我们不在自己编写的操作系统中使用它。
///
///
///
///

#![no_std]
#![no_main]

use core::panic::PanicInfo;

/// 这个函数将在panic时被调用
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop{}
}

#[no_mangle]
pub extern "C" fn _start() -> ! {
    loop {}
}
