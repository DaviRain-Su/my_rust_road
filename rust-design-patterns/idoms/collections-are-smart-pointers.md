

# Collections are smart pointers

## 描述

使用Deref triat 把集合当作智能指针，提供对数据的拥有和借用视图。

## 例子

```rust
use std::ops::Deref;

struct Vec<T> {
  data: T,
  // ...
}
impl <T> Deref for Vec<T> {
  type Target = [T];
  
  fn deref(&self) -> &[T] {
    // ...
  }
}
```

Vev < T > 是拥有Ts的集合，切片&[T] 是借用Ts的集合,实现Deref 为 Vec 允许隐式借用从&Vec< T >到&[T]， 并且包括自动解引用，并且包括自动解引用搜索中的关系。你可能期望为Vecs实现大多数方法都是为片实现的。

参见String 和&str.

## 动机

所有权和借用是Rust语言的关键方面，为了提供良好的用户体验，数据结构必须正确地解释这些语义。当实现一个拥有其数据的数据结构时，提供该数据的借用视图可以提供更多灵活的API

## 优点

大多数方法智能为借用视图实现，因此他们对于所有视图是隐式的。

让客户在借用或拥有数据之间做出选择。

## 缺点

边界检查时，只能通过解引用获得的方法和trait没有被考虑在内，所有使用这种模式的数据结构的泛型会变得复杂（参见Borrow和AsRef triat等）

## 讨论

智能指针和集合是类似的：智能指针指向单个对象，而集合指向多个对象，从类型系统的角度来看，两者没有什么区别。如果访问每个数据的唯一方式是通过收集，而且收集负责删除数据（即使在共享所有权的情况下，某种借用的视图可能是适当的）。则收集拥有其数据。如果一个集合拥有它的数据，通常提供一个借用的数据视图是有用的，这样他就可以被多重引用。

大多数智能指针（例如Foo < T >) 实现Deref < Target = T> 但是，集合通常会借用对自定义类型的引用。[T]和str有一些语言支持，但是在一般情况下，这是不必要的，Foo < T > 可以实现Deref < Target = Bar < T >> 其中Bar 是一个动态大小的类型，而Bar < T > 是Foo < T > 中数据的一个借用视图。

通常，有序的集合将实现Index为Ranges以提供切片语法。这个目标借用将提供借用视图。

## 参见 

Deref polymorphism anti-pattern 

Documentation for Deref triat. 



