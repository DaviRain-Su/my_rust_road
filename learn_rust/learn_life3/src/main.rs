#[derive(Debug)]
struct A<'a> {
    name: &'a str,
}
fn main() {
    let n = String::from("hello");
    let a = A { name: &n };
    println!("{:#?}", a);
    println!("Hello, world!");

    let s = get_a_str(&n);
    println!("s = {}", s);
}

// 2 生命周期省略
fn get_a_str(s: &str) -> &str {
    s
}
// 1 没有生命周期注解却能够编译，原因： 早期的rust中必须显式的生命周期，后来
// rust团队将根据明确的模式进行了注解的简化
// 2 遵守生命周期省略规则的情况下能明确变量的声明周期，则无需明确指定生命周期。函数
// 或方法的参数的生命周期称为输入生命周期，而返回值的生命周期称为输出生命周期。
// 3 编译器采用的三条规则判断引用何时不需要生命周期注解，当编译器检查完这三条规则后仍然不能计算出引用的生命周期，
// 则会停止并生成错误。
// 4 生命周期注解省略规则适用于fn定义以及impl块定义，如下：
// a 每个引用的参数都有它自己的生命周期参数，例如：
//  一个引用参数的函数，其中只有一个生命周期：fn foo<'a>(x: &'a i32);
//  两个引用参数的函数，则由两个生命周期: fn foo<'a, 'b>(x: &'a i32, y: &'a i32)
// b 如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数
//  fn foo(x: &i32) -> &i32 ==> fn foo<'a>(x: &'a i32) -> &'a i32
// c 如果方法有多个输如生命周期参数，不过其中之一因为方法的缘故为&self或者&mut self, 
// 那么self的生命周期被赋予所有输出生命周期参数。
// fn function(&self, x: &str, y: &str, ...) -> &str;
